<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Project</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
<div id="container"></div>

<script src="./libs/three.js"></script>
<script src="./libs/cannon.js"></script>
<script src="./libs/PointerLockControls.js"></script>


<script type="module">
    import Stats from './libs/stats.module.js';

    const container = document.getElementById('container');

    var stats = new Stats();
    container.appendChild( stats.dom );

    var world;
    var dt = 1 / 60;

    var constraintDown = false;
    var cameraBody;
    var camera, scene, renderer, gplane=false, clickMarker=false;
    var geometry, material, markerMaterial, gplaneMaterial, mesh;
    var controls, time = Date.now();

    var jointBody, constrainedBody, mouseConstraint;

    var N = 2;

    var raycaster;

    // To be synced
    var meshes=[], bodies=[];

    initPointerLock();
    initCannon();
    init();
    animate();

    function init() {
        raycaster = new THREE.Raycaster();

        // scene
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog( 0x000000, 500, 10000 );

        // camera
        camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 0.5, 10000 );
        camera.position.set(10, 2, 0);
        controls = new PointerLockControls(camera, cameraBody);
        scene.add(controls.getObject());

        // lights
        var light, materials;
        scene.add( new THREE.AmbientLight( 0x666666 ) );

        light = new THREE.DirectionalLight( 0xffffff, 1.75 );
        var d = 20;

        light.position.set( d, d, d );

        light.castShadow = true;

        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;

        light.shadow.camera.left = -d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = -d;

        light.shadow.camera.far = 3*d;
        light.shadow.camera.near = d;

        scene.add( light );

        // floor
        geometry = new THREE.PlaneGeometry( 100, 100, 1, 1 );
        material = new THREE.MeshLambertMaterial( { color: 0x777777 } );
        gplaneMaterial = new THREE.MeshLambertMaterial( { side: THREE.BackSide } );
        markerMaterial = new THREE.MeshLambertMaterial( { color: 0xff0000 } );

        mesh = new THREE.Mesh( geometry, material );
        mesh.castShadow = true;
        mesh.quaternion.setFromAxisAngle(new THREE.Vector3(1,0,0), -Math.PI / 2);
        mesh.receiveShadow = true;
        scene.add(mesh);

        // cubes
        var cubeMesh;
        var cubeGeo = new THREE.BoxGeometry( 1, 1, 1, 10, 10 );
        var cubeMaterial = new THREE.MeshPhongMaterial( { color: 0x888888} );
        for(var i=0; i<N; i++){
            cubeMesh = new THREE.Mesh(cubeGeo, cubeMaterial);
            cubeMesh.castShadow = true;
            meshes.push(cubeMesh);
            scene.add(cubeMesh);
        }

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor( scene.fog.color );

        container.appendChild( renderer.domElement );

        renderer.shadowMap.enabled = true;

        window.addEventListener( 'resize', onWindowResize, false );

        window.addEventListener("mousemove", onMouseMove, false );
        window.addEventListener("mousedown", onMouseDown, false );
        window.addEventListener("mouseup", onMouseUp, false );
        window.addEventListener("keydown", onKeyDown, false);
    }

    function setClickMarker(x,y,z) {
        if(!clickMarker){
            var shape = new THREE.SphereGeometry(0.2, 8, 8);
            clickMarker = new THREE.Mesh(shape, markerMaterial);
            scene.add(clickMarker);
        }
        clickMarker.visible = true;
        clickMarker.position.set(x,y,z);
    }

    function removeClickMarker(){
        clickMarker.visible = false;
    }

    function onMouseMove(e){
        // Should be consolidated to updateConstraint()
        // Move and project on the plane
        if (gplane && mouseConstraint) {
            var pos = projectOntoPlane(e.clientX,e.clientY,gplane,camera);
            if(pos){
                setClickMarker(pos.x,pos.y,pos.z,scene);
                moveJointToPoint(pos.x,pos.y,pos.z);
            }
        }
    }

    function onMouseDown(e){
        // Find mesh from a ray
        var entity = findNearestIntersectingObject(camera,meshes);
        var pos = entity.point;
        if(pos && entity.object.geometry instanceof THREE.BoxGeometry){
            constraintDown = true;
            // Set marker on contact point
            setClickMarker(pos.x,pos.y,pos.z,scene);

            // Set the movement plane
            setScreenPerpCenter(pos,camera);

            var idx = meshes.indexOf(entity.object);
            if(idx !== -1){
                addMouseConstraint(pos.x,pos.y,pos.z,bodies[idx]);
            }
        }
    }

    function onKeyDown(e) {
        switch (e.code) {
            case "KeyR":
            resetPhysics();
        }
    }

    // This function creates a virtual movement plane for the mouseJoint to move in
    function setScreenPerpCenter(point, camera) {
        // If it does not exist, create a new one
        if(!gplane) {
            var planeGeo = new THREE.IcosahedronGeometry(camera.position.distanceTo(point),4);
            var plane = gplane = new THREE.Mesh(planeGeo,gplaneMaterial);
            plane.visible = false; // Hide it..
            scene.add(gplane);
        } else {
            var planeGeo = new THREE.IcosahedronGeometry(camera.position.distanceTo(point),4);
            gplane.geometry.dispose();
            gplane.geometry = planeGeo;
        }
    }

    function onMouseUp(e) {
        constraintDown = false;
        // remove the marker
        removeClickMarker();

        // Send the remove mouse joint to server
        removeJointConstraint();
    }

    var lastx,lasty,last;
    function projectOntoPlane(screenX,screenY,thePlane,camera) {
        var x = screenX;
        var y = screenY;
        var now = new Date().getTime();
        // project mouse to that plane
        var hit = findNearestIntersectingObject(camera,[thePlane]);
        lastx = x;
        lasty = y;
        last = now;
        if(hit)
            return hit.point;
        return false;
    }
    function findNearestIntersectingObject(camera,objects) {
        // Get the picking ray from the point
        raycaster.setFromCamera(new THREE.Vector2(), camera);

        // Find the closest intersecting object
        // Now, cast the ray all render objects in the scene to see if they collide. Take the closest one.
        var hits = raycaster.intersectObjects(objects);
        var closest = false;
        if (hits.length > 0 && hits[0].distance < 8) {
            closest = hits[0];
        }

        return closest;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        requestAnimationFrame(animate);
        updatePhysics();

        // definitely needs to be moved :/
        if (gplane) {
            // Center plane at camera position
            gplane.position.copy(camera.position);
            if (mouseConstraint) {
                var pos = projectOntoPlane(lastx,lasty,gplane,camera);
                if(pos){
                    setClickMarker(pos.x,pos.y,pos.z,scene);
                    moveJointToPoint(pos.x,pos.y,pos.z);
                }
            }
        }

        stats.update();
        controls.update(Date.now() - time);
        render();
        time = Date.now();
    }

    function updatePhysics(){
        world.step(dt);
        for(var i=0; i !== meshes.length; i++){
            meshes[i].position.copy(bodies[i].position);
            meshes[i].quaternion.copy(bodies[i].quaternion);
        }
    }

    function resetPhysics() {
        // Objects
        for(var i=0; i !== meshes.length; i++){
            bodies[i].position.set(Math.random(), 3+i*2, Math.random());
            bodies[i].velocity.setZero();
            bodies[i].angularVelocity.setZero();
            bodies[i].quaternion.setFromEuler(0, 0, 0, "XYZ");
        }

        // Camera
        controls.reset();
    }

    function render() {
        renderer.render(scene, camera);
    }

    function initCannon(){
        // Setup our world
        world = new CANNON.World();
        world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;

        world.gravity.set(0,-10,0);
        world.broadphase = new CANNON.NaiveBroadphase();

        // Create boxes
        var mass = 5, radius = 1.3;
        var boxBody;
        var boxShape = new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5));
        for(var i=0; i<N; i++){
            boxBody = new CANNON.Body({ mass: mass });
            boxBody.addShape(boxShape);
            boxBody.position.set(Math.random(),3+i*2,Math.random());
            world.addBody(boxBody);
            bodies.push(boxBody);
        }

        // Create a plane
        var groundShape = new CANNON.Plane();
        var groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
        world.addBody(groundBody);

        // Joint body
        var shape = new CANNON.Sphere(0.1);
        jointBody = new CANNON.Body({ mass: 0 });
        jointBody.addShape(shape);
        jointBody.collisionFilterGroup = 0;
        jointBody.collisionFilterMask = 0;
        world.addBody(jointBody);

        // Camera body
        var cameraShape = new CANNON.Sphere(radius);
        cameraBody = new CANNON.Body({ mass: mass });
        cameraBody.addShape(cameraShape);
        cameraBody.position.set(5,1,0);
        cameraBody.linearDamping = 0.9;
        world.addBody(cameraBody);
    }

    function addMouseConstraint(x,y,z,body) {
        // The cannon body constrained by the mouse joint
        constrainedBody = body;

        // Vector to the clicked point, relative to the body
        var v1 = new CANNON.Vec3(x,y,z).vsub(constrainedBody.position);

        // Apply anti-quaternion to vector to tranform it into the local body coordinate system
        var antiRot = constrainedBody.quaternion.inverse();
        var pivot = antiRot.vmult(v1); // pivot is not in local body coordinates

        // Move the cannon click marker particle to the click position
        jointBody.position.set(x,y,z);

        // Create a new constraint
        // The pivot for the jointBody is zero
        mouseConstraint = new CANNON.PointToPointConstraint(constrainedBody, pivot, jointBody, new CANNON.Vec3(0,0,0));

        // Add the constriant to world
        world.addConstraint(mouseConstraint);
    }

    // This functions moves the transparent joint body to a new postion in space
    function moveJointToPoint(x,y,z) {
        // Move the joint body to a new position
        jointBody.position.set(x,y,z);
        mouseConstraint.update();
    }

    function removeJointConstraint(){
        // Remove constriant from world
        world.removeConstraint(mouseConstraint);
        mouseConstraint = false;
    }

    function initPointerLock() {
        const havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

        if (havePointerLock) {
            const element = document.body;

            const pointerlockchange = function (event) {
                controls.enabled = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element;
            };

            /*const pointerlockerror = function (event) {

            };*/

            // Hook pointer lock state change events
            document.addEventListener( 'pointerlockchange', pointerlockchange, false );
            document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
            document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

            //document.addEventListener( 'pointerlockerror', pointerlockerror, false );
            //document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
            //document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

            document.addEventListener('click', function ( event ) {
                if (controls.enabled) return;
                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                if ( /Firefox/i.test( navigator.userAgent ) ) {
                    var fullscreenchange = function ( event ) {
                        if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
                            document.removeEventListener( 'fullscreenchange', fullscreenchange );
                            document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                            element.requestPointerLock();
                        }
                    }

                    document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                    document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                    element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                    element.requestFullscreen();
                } else {
                    element.requestPointerLock();
                }
            }, false);
        } else {
            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
        }
    }
</script>
</body>
</html>